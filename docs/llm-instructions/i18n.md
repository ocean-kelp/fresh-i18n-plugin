# i18n Usage Guide (@xiayun/fresh-i18n)

This guide covers recommended patterns for using the Fresh i18n plugin
effectively.

## Quick Reference

```tsx
// Routes - use state.t directly
const t = state.t;
t("common.actions.save"); // ✅

// Islands - pass translation data as props
const t = translate(translationData, config);
t("common.actions.save"); // ✅
```

---

## File Organization

### Nested Structure (Recommended)

Organize translations with unlimited nesting for better maintainability:

```
locales/
├── en/
│   ├── common/
│   │   ├── actions.json      → common.actions.*
│   │   ├── states.json       → common.states.*
│   │   └── labels.json       → common.labels.*
│   ├── features/
│   │   ├── dashboard.json    → features.dashboard.*
│   │   └── users/
│   │       ├── list.json     → features.users.list.*
│   │       └── form.json     → features.users.form.*
└── es/ (same structure)
```

**File naming:**

- Use kebab-case for file names: `pdi-modals.json` → auto-converts to
  `pdiModals`
- Folders become namespace levels: `features/navigator/dashboard.json` →
  `features.navigator.dashboard`

### Content Organization

```json
// common/actions.json
{
  "save": "Save",
  "cancel": "Cancel",
  "edit": "Edit",
  "delete": "Delete"
}

// common/states.json
{
  "loading": "Loading...",
  "saving": "Saving...",
  "success": "Success!",
  "error": "Error"
}

// features/dashboard.json
{
  "title": "Dashboard",
  "welcomeMessage": "Welcome to your dashboard",
  "stats": {
    "users": "Total Users",
    "revenue": "Revenue"
  }
}
```

---

## Usage Patterns

### 1. Routes (Server-side)

```tsx
import { define } from "@/utils.ts";

export default define.page(function MyRoute({ state }) {
    const t = state.t;
    const locale = state.locale;

    return (
        <div>
            <h1>{t("features.dashboard.title")}</h1>
            <button>{t("common.actions.save")}</button>
        </div>
    );
});
```

### 2. Islands (Client-side)

**Route Handler:**

```tsx
export const handler = define.handlers({
    GET(ctx) {
        return {
            data: {
                translationData: ctx.state.translationData,
                translationConfig: {
                    locale: ctx.state.locale,
                    defaultLocale: ctx.state.translationConfig?.defaultLocale,
                    fallbackKeys: Array.from(
                        ctx.state.translationConfig?.fallbackKeys ?? [],
                    ),
                },
            },
        };
    },
});
```

**Route Component:**

```tsx
export default function MyRoute({ data, state }) {
    return (
        <MyIsland
            translationData={data.translationData}
            translationConfig={data.translationConfig}
        />
    );
}
```

**Island:**

```tsx
import { translate, TranslationConfig } from "@xiayun/fresh-i18n";

interface Props {
    translationData: Record<string, unknown>;
    translationConfig?: {
        locale?: string;
        defaultLocale?: string;
        fallbackKeys?: string[];
    };
}

export default function MyIsland(
    { translationData, translationConfig }: Props,
) {
    const config: TranslationConfig | undefined = translationConfig
        ? {
            ...translationConfig,
            fallbackKeys: new Set(translationConfig.fallbackKeys ?? []),
        }
        : undefined;

    const t = translate(translationData ?? {}, config);

    return <button>{t("common.actions.save")}</button>;
}
```

### 3. Namespaced Translators (Recommended)

Avoid repetitive namespace prefixes:

```tsx
import { createNamespacedTranslator } from "@xiayun/fresh-i18n";

export default function MyComponent({ state }) {
    const t = state.t;

    // Create scoped translators
    const tActions = createNamespacedTranslator(t, "common.actions");
    const tStates = createNamespacedTranslator(t, "common.states");
    const tDashboard = createNamespacedTranslator(t, "features.dashboard");

    return (
        <div>
            <button>{tActions("save")}</button>{" "}
            {/* → t("common.actions.save") */}
            <button>{tActions("cancel")}</button>{" "}
            {/* → t("common.actions.cancel") */}
            <p>{tStates("loading")}</p> {/* → t("common.states.loading") */}
            <h1>{tDashboard("title")}</h1>{" "}
            {/* → t("features.dashboard.title") */}
        </div>
    );
}
```

**Nested namespacing:**

```tsx
const tFeatures = createNamespacedTranslator(t, "features");
const tDashboard = createNamespacedTranslator(tFeatures, "dashboard");

tDashboard("title"); // → t("features.dashboard.title")
```

---

## Best Practices

### ✅ DO

1. **Reuse common keys** - Check for existing translations before creating new
   ones
2. **Use namespaced translators** - Eliminate repetitive prefixes
3. **Organize by feature** - Group related translations in folders
4. **Add to both EN and ES** - Always maintain both language files
5. **Use descriptive keys** - `goalBaseline` not `field1`
6. **Test both locales** - Verify translations work in all languages

### ❌ DON'T

1. **Don't duplicate translations** - Reuse `common.actions.save` instead of
   creating `myFeature.save`
2. **Don't use partial paths** - Always use full namespace:
   `common.actions.save` not `actions.save`
3. **Don't hardcode strings** - Always use translation keys
4. **Don't forget Spanish** - Every EN key needs an ES translation
5. **Don't create flat structures** - Use nested folders for organization
6. **Don't skip maxLength** - Always add maxLength to inputs matching backend
   limits

---

## Key Organization Strategy

### Common Namespace

Truly shared strings used across multiple features:

- `common.actions.*` - Universal actions (save, cancel, edit, delete)
- `common.states.*` - Loading/success/error states
- `common.labels.*` - Generic form labels (name, description, date)
- `common.navigation.*` - Nav items, breadcrumbs
- `common.messages.*` - Generic user messages

### Feature Namespaces

Domain-specific translations:

- `features.dashboard.*` - Dashboard-specific strings
- `features.users.*` - User management
- `features.settings.*` - Settings page

### Benefits

- **No confusion** - Clear where each translation belongs
- **Easy to find** - Logical organization by feature
- **Scalable** - Add new features without bloating common
- **Maintainable** - Delete feature folder when removing a feature

---

## Troubleshooting

### Missing Translation Key Warning

```
❌ Missing translation key: "common.actions.save"
```

**Fix:**

1. Check the key exists in both `en/` and `es/` locale files
2. Verify the full path is correct (including all parent namespaces)
3. Ensure the file structure matches the namespace path

### TypeScript Errors in Islands

Islands cannot receive `state.t` as props (functions can't be serialized in
Fresh 2.x).

**Fix:** Pass `translationData` and `translationConfig` as shown in pattern #2
above.

### Wrong Translations Showing

If you see the wrong language or fallback indicators:

**Fix:**

1. Check `state.locale` value matches expected locale
2. Verify translation files exist for that locale
3. Check fallback configuration in plugin setup

---

## Plugin Configuration

```tsx
// main.ts
import { i18nPlugin } from "@xiayun/fresh-i18n";

app.use(i18nPlugin({
    languages: ["en", "es"],
    defaultLanguage: "en",
    localesDir: "./locales",

    // Optional: Show fallback indicators in production
    fallback: {
        enabled: true,
        showIndicator: true,
        indicatorFormat: (text, locale) => `${text} [${locale}]`,
    },
}));
```

---

## Reference

Full documentation:
[fresh-i18n GitHub](https://github.com/ocean-kelp/fresh-i18n)
